%title 简介

=简介=

==I/O与CPU时间比较==

* 数据处理时间一般比较快
* 数据I/O比较慢，往往不是一个数量级。
* 代码优化所带来的的回报，可能被低效的i/o轻易抵销掉。
 
     [t_1_1.png]
     
==Java的传统I/O==

* CPU已经基本上不在是束缚，JVM的执行效率已经很高，和本地代码差距已不大。
* JVM的传统I/O实现有问题
* 操作系统喜欢大块移动数据，像铲车一样。
* JVM喜欢喜欢操纵小数据，比如一个字节或几行文本，像小铲一样。
* JVM要花大量的时间拆分数据，拷贝一小块数据要往返多层对象。
* 传统I/O其实也可以操作大数据，使用RandomAccessFile,效率很高。
 
==I/O概念==

* 缓冲区
* 内核空间与用户空间
* 虚拟内存
* 分页技术
* 文件I/O与流I/O
* 多工I/O(就绪性选择）
 
==缓冲区==

* I/O就是对缓冲区的操作
* 读：将缓冲区用数据填满
* 写：将缓冲区的数据排干
* 把数据从外部磁盘读入运行中的进程内存区的过程
  # 进程向内核发起系统调用read(), 要求其缓冲区填满
  # 内核向磁盘控制硬件发起命令，要求从外部磁盘读入数据。
  # DMA(Direct Memory Access)将数据读入内核空间缓冲区，这一步由DMA完成，无需CPU协助。
  # 内核将数据从内核空间缓冲区读入进程调用read()时指定的进程缓冲区
      [p_1_1.png]
* 内核空间与用户空间区别
  * <b>用户空间</b>，常规进程驻留区域，非特权空间，代码无权直接访问硬件。
  * <b>内核空间</b>，操作系统驻留区域，特权空间，代码可以直接访问硬件。
* 进程发起I/O请求时， 通过一系统调用将控制权交给内核
    系统调用open() read() write() close()
* 进程请求的数据可能已经在内核空间，而无需从外部磁盘读取，这时只是简单的将数据拷贝进用户缓冲区。
* 为什么需要内核空间，而不是直接读入用户空间
  * 硬件通常不能直接访问用户空间
  * DMA 操作的是固定块大小的数据
  * 用户请求的数据大小不一，是不整齐的
  * 内核负责分解，整合数据，充当了中间人的角色.
 
===发散/汇聚===

* <b>进程只需一个系统调用</b>,就可以传入多个缓冲区,这样内核就可以顺序填满或排干多个缓冲区.
* <b>读的时候</b>,内核将数据<b>分散</b>开填入多个缓冲区.
* <b>写的时候</b>,内核将多个缓冲区排干,将数据<b>汇聚起来</b>, 写入磁盘.
* 好处:
  # 只需一个系统调用,避免多次系统调用
  # 内核可以优化处理
  # 如果是多CPU,可以同时对多个缓冲区进行填充事排干
   
    [p_1_2.png]

==虚拟内存==

虚拟内存,就是以虚拟的内存地址代替真实的物理内存地址:
# 一个以上的虚拟内存地址可以指向同一个物理内存地址.
# 虚拟内存空间可能大于物理内存
 
===多重映射===

* 可以将内核缓冲区和用户缓冲区映射到相同的物理地址上
* 可以避免把数据从内核缓冲区再次拷到用户缓冲区
* 前提:
  # 内核缓冲区和用户缓冲区使用相同的页对齐
  # 缓冲区大小必须是磁盘控制器块(通常是512字节)的倍数
  
    [p_1_3.png]
    
===内存页===

* 操作系统通常把内存地址空间划分为页
* 页也就是固定大小的字节组
* 页的大小通常为磁盘块的整数倍,通常为2次幂,为了寻址简单
* 典型的页大小:1024 2048 4096
* 虚拟内存页与物理内存页总是相同

    [p_1_4.png]
    
===分页===

* 为了支持虚拟内存的寻址空间大于物理内存的地址空间 
* 必须进行虚拟内存分页, 经常称之为交换,它是是在进程层面完成的,而非页层面
* 也就是虚拟内存的内存页可以继续存在于外部磁盘中,这样就可以空出物理内存,供其他当前要使用的虚拟内存页使用.
* 物理内存充当了虚拟内存页的高速缓存
* 所谓分页区,就是那些调出物理内存,转而存到外部磁盘的虚拟内存页
* 下图显示了4个进程,每个进程拥有自己的虚拟空间,进程A有5个虚拟内存页,其中A1,A4两个虚拟内存页在物理内存,其他在分页区,即存储在磁盘上.
    [p_1_5.png]
* 内存页的大小是磁盘块的倍数,这样内核就可以直接命令磁盘控制硬件将内存页存储到磁盘上, 需要进再装入.
* <b>这样所有的磁盘I/O都在页层面完成</b>
* <b>对于采用分页技术的现代操作系统,这是数据往来于磁盘与物理内存的唯一方式</b>
    
===内存页调度===

* 现代CPU包含一个MMU,内存管理单元.
* 逻辑上位于CPU与物理内存之间.
* 它包含了虚拟内存地址向物理内存地址转换时所需的映射信息.

    
    

 


