%title 类型、运算符，长度

=类型、运算符，长度=

日期: 2012-04-05 19:04

%toc

==数据类型及长度==

===基本数据类型===
* `char`  字符型，占用一个字节，用于存放本地字符集中的一个字符
* `int` 整数型，通常反映机器中整数的自然长度
* `float` 单精度浮点数
* `double` 双精度浮点数
 
===限定符short long===
* 用于限定`int`
{{{ class="brush:c"
  short int sh;
  long int counter;
  }}}
* `int`可以省略
{{{ class="brush:c"
  short sh;
  long counter;
  }}}
* short与int至少为16位
* long至少为32位
* short不得长于int
* int不得长于long

===限定符signed unsigned===
* 可以限定任何类型
* 不带限定符的`char`是否带符号取决于具体的机器
* 但可打印的字符总是正值
 
===long double===
* 表示高精度浮点数
* 浮点型的长度也取决于具体的机器
 
 <b>有关类型长度定义的常量以及与机器和编译相关的属性可以在头文件<limits.h>与<float.h>中找到</b>
 
==常量==

===数字常量===

* <b>int:</b> `100`
* <b>long(后缀为l或L):</b> `100l 100L`
* <b>unsigned(后缀为u或U):</b> `100u 100U 100ul 100UL`
* <b>double(不带后缀):</b> `1.24, 1e-2`
* <b>float(后缀为f或F):</b> `1.24f, 1.24F, 1e-2f, 1e-2F`
* <b>long double(后缀为l或L):</b> `1.24l, 1.24L, 1e-2l, 1e-2L`
* <b>八进制(前缀0):</b> `037`
* <b>十六进制(前缀为0x或0X):</b> `0x1f, 0X1F, 0XFUL(表示为unsigned long, 15)`

===字符常量===

* 一个字符常量是一个整数
* 书写时将一个字符括在单引号中，如：`'x'`
* 转义字符：`'\n', '\t'`
* 八进制表示法<b>\ooo</b>,ooo表示1～3个八进制数：`'\013' 表示VTAB`
* 十六进制表示法<b>\xhh</b>,hh表示一个或多个十六进制数：`'\xb' 表示VTAB`
* <b>'\0'表示值为0的字符，也就是空字符null</b>
 
===常量表达式在编译进求值，而不是在运行时求值===

{{{ class="brush:c"
 #define MAXLINE 1000
 char line[MAXLINE+1];
 //或：
 #define LEAP 1 /* in leap years */
 int days[31+28+LEAP+31+30+31+30+31+31+30+31+30+31];
  }}}

===字符串常量===

* 又叫字符串字面值
* 就是字符数组，以`'\0'`结尾
* 所以物理存储中，比双引号中多一个
* `'x'` 是一个整数
* `"x"` 是一字符数组，包含：`'x' '\0' `
 
===枚举常量===

{{{ class="brush:c"
 enum boolean {NO,YES}
  }}}

* _*就是一常量整型值列表*_
* 无显示说明: 第一个值为0, 第二个值为1, 依此类推
* 若只指定部分值，未指定的根据最后一个指定的向后递增
{{{ class="brush:c"
 //FEB为2，MAR为3 ... ...
 enum months {JAN=1,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC}
  }}}
* 不同枚举中的名字必须互不相同
* 同一枚举中的不同名字可以拥有相同的值
* 可以生成枚举类型的变量，但编译器并不会检查存储的值是否为合法的的枚举值。
* 但它提供检查的机会
* 通常情况下，比`#define`好
 
==声明==

* 所有变量必须先声明再使用。
* 可以在声明的同时进行初始化。
* 非自动变量只能初始化一次, 并且是在程序开始执行之前, 初始化表达式必须为常量表达式	
* 默认情况下，外部变量与静态变量被初始化为0，未显示初始化的自动变量为未定义值，即无效值。
* *任何变量声明都可以使用限定符const:* 
  * 表示该变量值不能修改
  * 如果是数组，表示数组所有元素的值都不能修改
  * 如果试图修改const限定的变量，其结果取决于具体的实现

==算术运算符==

* + - * / %
* % 不能用于float 和double
* 若存在负操作数，整数除法截取方向与取模结果依赖于具体的机器实现
* 优先级：二元+ -  <  * / % < 一元+ -
* 采用从左到右的接合规则
 
==关系运算符与逻辑运算符==
优先级：
* > >= < <=  相同, 但低于 == !=
* && 高于 ||
* ! 将非0操作数转换为0, 将0转换为1
 
==类型转换==

当运算符的几个操作数类型不一致时，需要转换成共同的数据类型。

*自动转换*, 将“比较窄”的类型转换成“比较宽”的类型，并且不丢失信息。

*char* 为比较窄的整型，可以放心自由使用。

*<ctype.h>* 头文件定义了一组与字符集无关的测试和转换函数，比如： `tolower(c)`

*c并没有规定char是有符号的还是无符号的* 所以当转换成整数时，有没有可能是负的，这要依赖于具体的机器实现。<br/>
*但c规定了标准打印字符都是正的*

*逻辑表达式为真时，值为1，为假时，值为0* 
{{{ class="brush:c"
   d = '9' > '0'; // d 为 1
  }}}
  
===隐式转换=== 

如果两个操作数具有不同的类型时，需要将“较低”的类型转换为“较高”的类型，运算结果为较高的类型。 

如果没有unsigned操作数，使用如下规则:

# 如果一个为`long double`, 另一个转换为`long double`
# 如果一个为`double`,另一个转换为`double`
# 如果一个为`float`,另一个转换为`float`
# 将`char`与`short`转换为`int`
# 如果一个操作数为`long`,另一个也转换成`long`
 
*_注意：_*  表达式中的`float`并不会自动转换成`double`

如果操作数中包含unsigned，转换规则就会复杂一些，因为有符号数与无符号数的比较运算是和机器相的。
{{{ class="brush:c"
  //int为16位，long为32位
  -1L<1U;  //unsigned int 1 为提升为signed long 
  -1L>1UL; //signed long -1被提升为unsigned long, 变成一个很大的数
  }}}


赋值也要进行类型转换。

无论是否进行符号扩展，字符型变量都要转换成整形变量。

把较长的整数转换成较短的整数或字符型时，高位部分被丢弃。

float转换为int时，小数部分被截取掉。<br/>
double转换为float时，是四舍五入还是截取，要依赖于具体的实现。

参数传递给函数时，要进行类型转换。<br/>
没有函数原型（声明)的情况下，char与short被转换为int, float被转换为double.

显示强制类型转换： *(类型名)表达式* <br/>
*_注意：_*  强制类型转换只是生成一个新的指定类型的值，原变量的值并没改变.
它与其他一元操作符具有相同的优先级

通常情况下，函数是通过函数原型声明的，声明会对参数进行自动的强制类型转换。
{{{ class="brush:c"
  //声明：
  double sqrt(double);
  //调用
  sqrt(2); //int 2 会自动转型为double 2.0
  }}}
  

==自增、自减运算符==
{{{ class="brush:c"
  int n1,n2,a;
  n1=n2=5;
  a=n1++;        // a 等于 5
  a=++n2;        // a 等于 6
  }}}
  
==位操作符==

6个操作符，只能用于整型数，即只能用于： `char,short,int,long`


| &  | 按位与 AND           |
| \\ | 按位或 OR            |
| ^  | 按位异或 XOR         |
| << | 左移                 |
| >> | 右移                 |
| ~  | 按位求反, 一元操作符 |

_*算术移位与逻辑移位*_
* 对signed类型进行右移，左边空出的部分用符号位补，为算术移位
* 用0补为逻辑移位

_*将x的后６位置0:*_
{{{ class="brush:c"
  x = x & ~077;
  }}}
或：
{{{ class="brush:c"
  x = x & 0177700;
  }}}
_*注：*_ 上面的要好于下面的，因为下面的假定x为16位的数值。
上面的也没有增加额外的开销，因为`~077`是常量表达式，会在编译时求值。

==赋值运算符与表达式==

===赋值运算符===
* `+=` 被称为 _*赋值运算符*_
 {{{ class="brush:c"
   i += 2;
  }}}
* `expr1` 可以是一个表达式，而不一定是一个单独的变量
 {{{ class="brush:c"
  expr1 op= expr2;
  }}}


===赋值语句具有值===

* 值的类型为左操作数的值
* 值为赋值操作完成后的值
{{{ class="brush:c"
   while((c=getchar())!=EOF)
   //+= -= 也可以用在表达式中，但比较少使用
  }}}

===条件表达式===

{{{ class="brush:c"
   expr1 ? expr2 : expr3;
  }}}

* 条件表达式实际上是一种表达式，可以用在其他表达式可以使用的任何地方。
* 如果expr2与expr3类型不一样，其结果由前面所述的转换规则决定。
* 如果n为int, f为float, 例如:
 {{{ class="brush:c"
   (n > 0) ? f : n;
  }}}
  * _*无论n是否为正值，其表达式结果类型都为float*_

==运算符优先级与求值顺序==

===求值顺序===
* C语言未指定一个运算符中多个操作数的计算顺序，　&& || ?: , 除外
 {{{ class="brush:c"
   x = f() + g();
   //不知道f()和g()哪个先执行，如果f()是否执行会影响到g()的执行结果，比如f()会改变g()用到的变量
   //上面表达式的值就会因执行顺序不同而不同
  }}}
* C语言未指定函数调用中各个参数的计算顺序
 {{{ class="brush:c"
   printf("%d %d \n", n++, power(2,n);
   //你不知道n++与power(2,n)哪个先执行，
   //所以你不知道传入power(2,n)中的n是n的原始值还是n++运算后的值
  }}}
* 函数调用、嵌套赋值语句、自增与自减运算符都有可能产生副作用
 {{{ class="brush:c"
    a[i]=i++;
	//你不知道下标是i的原始值还是i++运算后的值
  }}}
* 如果代码的执行结果与求值顺序有关，就不是好的程序设计
