<!DOCTYPE html>
<html>
<head>

<title>Operating Systems Design and Implementation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../../js/jquery-1.6.4.min.js"></script>

<link rel="Stylesheet" type="text/css" href="../../js/sh/styles/shCore.css">
<link rel="Stylesheet" type="text/css" href="../../js/sh/styles/shThemeRDark.css">
<script type="text/javascript" src="../../js/sh/scripts/shCore.js"></script>
<script type="text/javascript" src="../../js/sh/scripts/shAutoloader.js"></script>

<script type="text/javascript" src="../../js/main.js"></script>
<script type="text/javascript" src="../../js/ASCIIMathML.js"></script>

<link rel="Stylesheet" type="text/css" href="../../style.css">
<link rel="Stylesheet" type="text/css" href="../../css/main.css">

</head>
<body>
	<div class="hidden">
		<input id="root_path" type="text" value="../../">
	</div>
	<div id="body-wrapper">
		<div id="container">
			<div id="top">
				<div id="page-title">
					<a href="../../index.html">烂笔头</a>
				</div>
				<ul id="top-nav">
				</ul>
			</div>
			<div id="middle">
				

<div class="toc">
<ul>
<li><a href="#toc_1">Operating Systems Design and Implementation</a>
<ul>
<li><a href="#toc_1.1">什么是操作系统</a>
<ul>
<li><a href="#toc_1.1.1">操作系统作为虚拟机</a>
<li><a href="#toc_1.1.2">操作系统作为资源管理器</a>
</ul>
<li><a href="#toc_1.2">操作系统发展历史</a>
<ul>
<li><a href="#toc_1.2.1">第一代计算机(1945 ~ 1955):真空管和插板</a>
<li><a href="#toc_1.2.2">第二代计算机(1955 ~ 1965):晶体管和批处理系统</a>
<li><a href="#toc_1.2.3">第三代计算机(1965 ~ 1980):集成电路芯片与多道程序</a>
<li><a href="#toc_1.2.4">第四代计算机(1980 ~ NOW):个人计算机</a>
</ul>
<li><a href="#toc_1.3">操作系统基本概念</a>
<ul>
<li><a href="#toc_1.3.1">进程Process</a>
<li><a href="#toc_1.3.2">文件File</a>
<li><a href="#toc_1.3.3">进程Process</a>
<li><a href="#toc_1.3.4">命令解释器Shell</a>
</ul>
<li><a href="#toc_1.4">系统调用System Calls</a>
<ul>
<li><a href="#toc_1.4.1">进程管理的系统调用Process management</a>
<li><a href="#toc_1.4.2">信号管理的系统调用System Calls for Signaling</a>
<li><a href="#toc_1.4.3">文件管理的系统调用System Calls for File System</a>
<li><a href="#toc_1.4.4">目录管理的系统调用System Calls for Directory Management</a>
<li><a href="#toc_1.4.5">保护系统调用System Calls for Protection</a>
<li><a href="#toc_1.4.6">时间系统调用System Calls for Time Management</a>
</ul>
</ul>
</ul>
</div>

<h1 id="toc_1">Operating Systems Design and Implementation</h1>

<ul>
<li>
软件分为系统软件和应用软件

<ul>
<li>
系统软件管理系统及应用程序

<li>
应用软件执行用户最终所需要的功能

<li>
最基本的系统软件就是操作系统

<li>
它控制计算机的所有的资源并提供开发应用程序的基础

</ul>
<li>
virtual machine

<ul>
<li>
在裸机上加载一层软件来管理整个系统，为用户提供一套更容易理解与编程的接口

<li>
这个接口叫virtual machine

<li>
层软件号操作系统

</ul>
<li>
微程序microprogram

<ul>
<li>
一层原始软件

<li>
控制设备并向上一层提供一套更清晰的清晰的接口

<li>
它实际上是一个解释器：也取得机器语言的指令，执行相应的指令

</ul>
<li>
精简指令集计算机（Reduced Instruction Set Computer, RISC)

<ul>
<li>
没有微程序层

</ul>
<li>
操作系统专指运行在内核态(kernel mode)或管态(supervisor mode)下的程序。

<ul>
<li>
它受硬件保护而免遭用户篡改

<li>
命令解释器 编译器 编辑器运行在用户态(user mode), 它们是应用程序。

</ul>
</ul>
  
<h2 id="toc_1.1">什么是操作系统</h2>
<h3 id="toc_1.1.1">操作系统作为虚拟机</h3>
<ul>
<li>
操作系统为用户提供一台等价的扩展计算机，或叫虚拟机，它比低层硬件更容易编程。

</ul>

<h3 id="toc_1.1.2">操作系统作为资源管理器</h3>
<ul>
<li>
跟踪资源的使用状况、满足资源请求、提高资源利用率，及协调各程序和用户对资源的使用冲突。

</ul>

<h2 id="toc_1.2">操作系统发展历史</h2>
<ul>
<li>
第一台数字计算机，英国数学家Charles Babbage设计，纯机械式，无操作系统

<li>
第一个程序员：Ada Lovelace,诗人拜伦的女儿。

</ul>

<h3 id="toc_1.2.1">第一代计算机(1945 ~ 1955):真空管和插板</h3>
<ul>
<li>
每一台都专门设计，使用机器语言，没有编程语言，没有操作系统

</ul>
 
<h3 id="toc_1.2.2">第二代计算机(1955 ~ 1965):晶体管和批处理系统</h3>
<ul>
<li>
卡片，磁带，批处理（读入一队作业，顺序执行），负责读入作业并输出结果的特殊程序就是操作系统的前身

</ul>
 
<h3 id="toc_1.2.3">第三代计算机(1965 ~ 1980):集成电路芯片与多道程序</h3>
<ul>
<li>
当一个作业在等待io时，cpu就会空闲下来，很浪费

<li>
<strong>多道程序(multiprogramming):</strong>

<ol>
<li>
将内存划分为几部分，每一部分存放一个作业

<li>
当一个作业在等待io时，另一个作业可以使用cpu

</ol>
<li>
<strong>spooling:</strong>

<ol>
<li>
Simultaneous Peripheral Operation On Line, 联机即时外设操作

<li>
可以很快的将卡片上的作业读入磁盘。

</ol>
<li>
<strong>分时系统(timesharing):</strong>

<ol>
<li>
多道程序的变种

<li>
每一个用户有一个终端

<li>
cpu轮流为它们服务

<li>
可以为用户提供交互式服务

<li>
每个用户感觉自己拥有一个完整的计算机

<li>
cpu空闲时可以执行后台大作业

</ol>
<li>
UNIX

<li>
POSIX

</ul>

<h3 id="toc_1.2.4">第四代计算机(1980 ~ NOW):个人计算机</h3>
<ul>
<li>
网络操作系统

<li>
分布式操作系统

</ul>


<h2 id="toc_1.3">操作系统基本概念</h2>

<p>
<strong>系统调用</strong>
</p>
<ul>
<li>
由操作系统提供的操作系统与用户程序之间交互的 <strong>扩展指令集</strong>

<li>
两大类

<li>
与进程相关的 <strong>系统调用</strong>

<li>
与文件相关的 <strong>系统调用</strong>

</ul>

<h3 id="toc_1.3.1">进程Process</h3>
<p>
<strong>进程Process</strong>
</p>
<ul>
<li>
一个进程本质上是一个程序的 <strong>执行</strong>

</ul>
<p>
<strong>地址空间address space</strong>
</p>
<ul>
<li>
每个进程拥有自己的address space: 0 ~ 最大值

<li>
address sapce 中有： 可执行程序， 程序数据， 程序的堆栈

</ul>
<p>
<strong>进程还包括：一组寄存器register 程序计数器program counter 指针stack pointer  其他硬件寄存器hardware register</strong>
<strong>进程表 process tabel:</strong>
</p>
<ul>
<li>
除address space之外的进程所有的信息都保存在一张表中

<li>
每一进程对应表中的一项

<li>
process table 是一个结构数组或链表

</ul>
<p>
<strong>一个进程包括:</strong>
</p>
<ul>
<li>
address space, 又叫内核映像core image

<li>
process table中的一项

</ul>
<p>
<strong>进程间通信</strong>
</p>

<p>
<strong>中断和信号</strong>
</p>

<p>
<strong>一个挂起的进程，需要再运行，则需要把进程暂停前的所有信息都保存下来</strong>
</p>


<h3 id="toc_1.3.2">文件File</h3>

<h3 id="toc_1.3.3">进程Process</h3>
<ul>
<li>
File

<li>
Directory

<li>
9位保护码

<li>
Mount

<li>
设备文件（Special File)

<ul>
<li>
块设备文件Block special files

<li>
字符设备文件Character special files

</ul>
<li>
piple

</ul>

<h3 id="toc_1.3.4">命令解释器Shell</h3>
<ul>
<li>
它不是操作系统的一部分

<li>
这是终端用户与操作系统之间的一个重要接口

</ul>

<h2 id="toc_1.4">系统调用System Calls</h2>
<ul>
<li>
POSIX标准

</ul>

<p>
<strong>进程管理Process Management:</strong>
</p>
<pre  class="brush:c">
    //创建一个child process
    pid = fork();
    
    //等待一个child process结束
    pid = waitpid (pid, &amp;statloc, opts)
    
    //老版本的waitpid
    s = waitpid (&amp;status)
    
    //替换一个进程的内核映象
    s = execve (name, argv, envp)
    
    //结束进程执行返回一个状态码
    exit (status)
    
    //设置数据段大小
    size = brk (addr)
    
    //返回调用者进程号
    pid = getpid ()
    
    //返回调用者组标识号
    pid = getpgrp ()
    
    //创建一个会话并返回其组标识号
    pid = setsid ()
    
    //用于调试
    l = ptrace (req, pid, addr, data)
</pre>
    
<p>
<strong>信号Signal</strong>
</p>
<pre  class="brush:c">
    //定义对信号的处理工作
    s = sigaction (sig, &amp;act, &amp;oldact)
    
    //从信号返回
    s = sigreturn (&amp;context)
    
    //检查或修改信号掩码mask
    s = sigprocmask (how, &amp;set, &amp;old)
    
    //获得阻塞信息集合
    s = sigpending (set)
    
    //替换信号掩码并挂起进程
    s = sigsuspend (sigmask)
    
    //给进程发送一个信号
    s = kill (pid, sig)
    
    //设置时间闹钟
    residual = alarm (seconds)
    
    //挂起调用进程直到下一个信号
    s = pause ()   
</pre>

<p>
<strong>文件管理File Management:</strong>
</p>
<pre  class="brush:c">
    //创建一个新文件
    fd = creat (name, mode)
    
    // 创建普通、设备文件或目录i节点
    fd = mknod (name, mode, addr)
    
    //打开一个文件进行只读或读写操作
    fd = open (file, how, ...)
    
    //关闭一个已打开的文件
    s = close (fd)
    
    //从文件读数据到缓冲区
    n = read (fd, buffer, nbytes)
    
    //从缓冲区将数据写入文件
    n = write (fd, buffer, nbytes)
    
    //移动文件指针
    pos = lseek (fd, offset, whence)
    
    //获取文件状态信息
    s = stat (name, &amp;buf)
    
    //获取文件状态信息
    s = fstat (fd, &amp;buf)
    
    //为打开的文件分配一个新的文件描述符
    fd = dup (fd)
    
    //创建一个管道
    s = pipe (&amp;fd[0])
    
    //对文件时行特殊操作
    s = ioctl (fd, request, argp)
    
    //检查文件的访问权限
    s = access (name, amode)
    
    //重命名文件
    s = rename (old, new)
    
    //文件加锁及其他操作
    s = fcntl (fd, cmd, ...)
</pre>
    
<p>
<strong>目录及文件系统管理Dir. &amp; File System Mgt:</strong>
</p>
<pre  class="brush:c">
    //创建一个新目录
    s = mkdir (name, mode)
    
    //删除一个目录
    s = rmdir (name)
    
    //创建一个新项name2，它指向name1
    s = link (name1, name2)
    
    //删除一个目录项
    s = unlink (name)
    
    //挂一个文件系统
    s = mount (special, name, flag)
    
    // Unmount a file system
    s = umount (special)
    
    //将缓存中的数据块回写到磁盘
    s = sync ()
    
    //改变工作目录
    s = chdir (dirname)
    
    //改变根目录
    s = chroot (dirname)
</pre>
    
<p>
<strong>保护Prodeciton:</strong>
</p>
<pre  class="brush:c">
    //修改文件的保护位
    s = chmod (name, mode)
    
    //获取调用进程的uid
    uid = getuid ()
    
    //获取调用进程的gid
    gid = getgid ()
    
    //设置调用进程的uid
    s = setuid (uid)
    
    //设置调用进程的gid
    s = setgid (gid)
    
    //修改文件的拥有者和组
    s = chown (name, owner, group)
    
    //修改文件模式掩码
    oldmask = umask (complmode)
    
</pre>
    
<p>
<strong>时间管理Time Management:</strong>
</p>
<pre  class="brush:c">
    //获取自19700101以来的秒数
    seconds = time (&amp;seconds)
    
    //获取自19700101以来的时间
    s = stime (tp)
    
    //设置文件最后访问时间
    s = utime (file, timep)
    
    //获取当前的用户和系统时间
    s = times (buffer)
    
</pre>
    
<h3 id="toc_1.4.1">进程管理的系统调用Process management</h3>

<p>
<strong>fork():</strong>
</p>
<ul>
<li>
fork是创建新进程的唯一途径

<li>
fork创建了一个调用者进程的精确副本：文件描述符，寄存器等所有内容

<li>
fork后原进程子进程各自执行，互不相关

<li>
fork时，两个进程的变量拥有相同的值，此后各自维护

<li>
fork()对子进程返回0， 对你进程返回一个正整数，为新子进程的pid

<li>
fork()可以以返回值区分是子进程还是你进程

<li>
shell框架demo:
<pre  class="brush:c">
        #define TRUE 1
        
        while (TRUE){                           /* repeat forever */
            type_prompt();                      /* display prompt on the screen */
            read_command(command, parameters);  /* read input from terminal */
            
            if (fork() != 0){                   /* fork off child process */
                /* Parent code. */
                waitpid(1, &amp;status, 0);         /* wait for child to exit */
            } else {
                /* Child code. */
                execve(command, parameters, 0); /* execute command */
            }
        }
</pre>

</ul>
    
<p>
<strong>exec():</strong>
</p>
<ul>
<li>
有三个参数：

<ol>
<li>
待执行文件名：用于替换内核映象

<li>
指向参数数组的指针

<li>
指向环境变量数组的指针

</ol>
<li>
简化版：<code>execl execv execle execve</code>

</ul>
 
<p>
<strong>main(argc, argv, envp):</strong>
</p>
<ul>
<li>
argc: 包括程序名在内的参数个数

<li>
argv: 指向参数数组的指针, argv[0]为程序名

<li>
envp: 环境变量指针

</ul>
 
<p>
<strong>进程的存储空间:</strong>
</p>
<ul>
<li>
分为三部分：正文段（text segment, 程序代码), 数据段（data segment,即变量), 堆栈段（stack segment)

<li>
data segment向上增长，stack segment向下增长；

<li>
statck segment的增长随程序的执行自动进行

<li>
data segment通过brk显示完成

<li>
data segment的结束指针必须小于stack segment的指针，不然会重叠，这是不允许的。

</ul>
 
<p>
<strong>getpid():</strong>
</p>
<ul>
<li>
获得当前进程的标识号

</ul>

<h3 id="toc_1.4.2">信号管理的系统调用System Calls for Signaling</h3>
<p>
<strong>收到一个未声明处理的signal:</strong>
</p>
<ul>
<li>
如果一个进程收到一个 <strong>未声明要接收的</strong> signal时，该进程被撤消，即被杀死

</ul>
 
<p>
<strong>声明要接收的signal:</strong>
</p>
<ol>
<li>
使用<code>sigaction</code>   

<li>
有两个参数，后两个是地址

<ul>
<li>
指明signal

<li>
要处理signal的procedure地址

<li>
signal原先处理procedure的地址

</ul>
</ol>
   
<p>
<strong>进程接收到一个signal时:</strong>
</p>
<ol>
<li>
将当前进程状态压栈

<li>
调用指定的signal处理procedure

<li>
处理结束，调用<code>sigreturn</code>,执行被signal中断的操作

</ol>

<p>
<strong>signal阻塞:</strong>
</p>
<ol>
<li>
signal可以被阻塞

<li>
阻塞的signal被扶起，直到被解除阻塞

<li>
<code>sigpromask</code>定义一个进程阻塞的信息集

<li>
<code>sigperding</code>查询因阻塞而挂起的信号集

<li>
<code>sigsuspend</code>进程用于设定阻塞信号位图，并将本身挂起

</ol>

<p>
<strong>忽略一个signal:</strong>
</p>
<ol>
<li>
<code>SIG_IGN</code>

<li>
忽略信号SIGINT
<pre  class="brush:c">
    sigaction(SIGINT, SIG_IGN, NULL);
</pre>

<li>
需要在执行exec前执行

</ol>

<p>
<strong>恢复一个signal默认处理:</strong>
</p>
<ol>
<li>
<code>SIG_DFL</code>

<li>
恢复信号SIGINT默认行为
<pre  class="brush:c">
    sigaction(SIGINT, SIG_DFL, NULL);
</pre>

</ol>
    
<p>
<strong>向指定进程发送一个signal:</strong>
</p>
<ol>
<li>
使用<code>kill</code>

<li>
signal 9(sigkill)不能被捕获或忽略

</ol>

<p>
<strong>alarm系统调用:</strong>
</p>
<ol>
<li>
参数：一个以秒为单位的间隔

<li>
时间到达，则向该进程发送一个sigalrm

<li>
任一时刻一个进程只能且个闹钟

</ol>
 
<p>
<strong>pause系统调用:</strong>
</p>
<ol>
<li>
挂起调用进程，直到信号到来

<li>
其他进程就可以使用cpu了

<li>
通常用于一个进程等待信号，又不需要什么操作时

</ol>
    
<h3 id="toc_1.4.3">文件管理的系统调用System Calls for File System</h3>
<p>
<strong>create系统调用:</strong>
</p>
<ol>
<li>
<code>fd = create("abc", 0751)</code>

<li>
创建文件

<li>
参数为：路径名，保护模式

<ul>
<li>
注意并不是把文件的权限设置为了0751, 而是要和umask指定掩码的反码相与后才是真正的权限

</ul>
<li>
并同时以写的方式打开，不管模式是什么

<li>
返回fd, 通过fd可以对文件进行写操作

<li>
对于一个已存在的文件进行该系统调用，将破坏该文件

<li>
已过时，由 <strong>open</strong> 代替

</ol>

<p>
<strong>mknod系统调用:</strong>
</p>
<ol>
<li>
<code>fd = mknod("/dev/tty2", 020744, 0x0402)</code>

<li>
创建设备文件

<li>
parameter 1:要创建的文件名

<li>
parameter 2:020744指明为一个字符设备文件，权限为rwxr--r--

<ul>
<li>
注意并不是把文件的权限设置为了0744, 而是要和umask指定掩码的反码相与后才是真正的权限

</ul>
<li>
parameter 3:高字节为主设备号4， 低字节为次设备号2

<li>
只能被超级用户调用 

</ol>
 
<p>
<strong>open系统调用:</strong>
</p>
<ol>
<li>
打开文件

<li>
parameter 1:文件路径可以是绝对路径，也可以是相对路径

<li>
parameter 2:打开方式，O_RDONLY O_WRONLY O_RDWR

<li>
return :fd可用于读写操作

<li>
用完后，需要调用close系统调用进行关闭.关闭后,fd可以被后面的系统调用重用

</ol>
 
<p>
<strong>read&amp;write系统调用:</strong>
</p>
<ol>
<li>
读写操作

</ol>
 
<p>
<strong>lseek系统调用:</strong>
</p>
<ol>
<li>
修改文件指针，read和write就可以在文件的任一位置进行读写了

<li>
paratmer 1: fd

<li>
paratmer 2: position

<li>
paratmer 3: 上一个参数position是相对于文件开头，当前position,文件末尾

<li>
return :    被修改后的绝对位置

</ol>

<p>
<strong>stat&amp;fstat系统调用:</strong>
</p>
<ol>
<li>
获取文件状态信息

<li>
都有两个参数

<li>
parameter 1:指定文件

<ul>
<li>
stat接收一个文件名

<li>
fstat接收一个fd

<li>
fstat适合一个打开的文件

</ul>
<li>
parameter 2:一个用来存放信息的结构
<pre  class="brush:c">
    struct stat{
        short st_dev;               /* device where i-node belongs */
        unsigned short st_ino;      /* i-node number */
        unsigned short st_mode;     /* mode word */
        short st_nlink;             /* number of links */
        short st_uid;               /* user id */
        short st_gid;               /* group id */
        short st_rdev;              /* major/minor device for special files */
        long st_size;               /* file size */
        long st_atime;              /* time of last access */
        long st_mtime;              /* time of last modification */
        long st_ctime;              /* time of last change to i-node */
    };
</pre>

</ol>

<p>
<strong>dup系统调用:</strong>
</p>
<ol>
<li>
用于文件描述符的操作

<li>
<code>n=dup(fd)</code>:将文件描述符n指向文件描述符fd把指向的文件，  <strong>n将是当前最小的可用的文件描述符</strong>

<li>
<code>dup2(fd, fd2)</code>:fd2为一个未被使用的文件描述符，将文件描述符fd2指向文件描述符fd把指向的文件

</ol>
 
<p>
<strong>pipe系统调用:</strong>
</p>
<ol>
<li>
<code>pipe(&amp;fd[0])</code>

<li>
创建一个管道

<li>
返回两个文件描述符，放于fd[0]和fd[1]

<li>
一个用于读一个用于写

</ol>
 
<p>
<strong>ioctl系统调用:</strong>
</p>
<ol>
<li>
用于设备文件

<li>
特别是字符设备文件

<li>
比如用于改变终端模式

<li>
<code>ioctl(fd, TCSETS, &amp;termios)</code>

</ol>
 
<p>
<strong>终端的三种模式:</strong>
</p>
<ol>
<li>
<strong>Cooked mode:</strong>

<ol>
<li>
删除、终止键正常工作

<li>
CTRL-S CTRL-Q 用于停止恢复终端输出

<li>
CTRL-D 文件终止符

<li>
CTRL-C interrupt signal

<li>
CTRL-\ quit signal并强制内核映象转储

</ol>
<li>
<strong>raw mode:</strong>

<ol>
<li>
上述功能都被禁止

<li>
数据不加处理的传给程序

<li>
从终端每读到一个字符都传给程序，而cooked会读完一行再传

</ol>
<li>
<strong>Cbreak mode:</strong>

<ol>
<li>
上述两者之间

<li>
删除、终止键、CTRL-D被禁止

<li>
CTRL-S, CTRL-Q, CTRL-C, and CTRL-\ 有效

<li>
同raw模式，不等一行结束，单个字符就会传给程序

</ol>
</ol>

<p>
<strong>access系统调用:</strong>
</p>
<ol>
<li>
检查对一个文件是否具有某种访问权限

</ol>
 
<p>
<strong>rename系统调用:</strong>
</p>
<ol>
<li>
重命名文件 

</ol>
 
<p>
<strong>fcntl系统调用:</strong>
</p>
<ol>
<li>
类似于ioctl

<li>
可用于文件加锁

<li>
可用于对文件的一部分进行加锁 解锁

<li>
可用于检测文件某部分是否被上锁

<li>
但本身不包括任何和锁相关的语义，由程序员自定义

</ol>
 
<h3 id="toc_1.4.4">目录管理的系统调用System Calls for Directory Management</h3>

<p>
<strong>mkdir&amp;rmdir系统调用:</strong>
</p>
<ol>
<li>
创建或删除 <strong>空目录</strong>

</ol>

<p>
<strong>link系统调用:</strong>
</p>
<ol>
<li>
<code>link("/usr/jim/memo", "/ur/ast/note");</code>

<li>
使 <strong>同一个文件</strong> 以不同的名称出现， 往往在不同的目录下

<li>
Unix中每个文件拥有一个唯一的标识符，叫做<code>i-number</code>, 它是一个指向表<code>i-nodes</code>的索引值

<li>
表中存储了谁拥有这个文件，及文件所占磁盘块的信息，等等

<li>
<strong>目录</strong> 也是一个文件，它由<code>i-number</code> 和 <code>file name</code>的对应信息组成, 每一个对应关系就是一个 dirctory entry

<ol>
<li>
早期目录文件中的 directory entry 由16byte组成，2byte存储i-number, 14byte存储文件名

<li>
后来为了支持长文件名，使用了新的数据结构，总体来说还是i-number, file-name pair

</ol>
<li>
可以看出link所做的工作，就是在 <strong>目录文件</strong> 中添加一个directory entry, 使用指定的name和i-number

<li>
系统调用<code>unlink</code>可以从 <strong>目录文件</strong> 中删除一个directory entry

<li>
表<code>i-nodes</code>中记录了每个<code>i-number</code>被directory entry引用的次数

<ol>
<li>
如果次数为0，说明没有directory entry 引用，该i-number代表的文件就可以删除了

</ol>
</ol>
   
<p>
<strong>mount&amp;umount系统调用:</strong>
</p>

<p>
<strong>sync系统调用:</strong>
</p>
<ol>
<li>
操作系统有一个缓存区，保存了最近经常被访问的磁盘数据，可以避免重复从磁盘读数据

<li>
但当缓冲区的数据被更改时，需要写回磁盘，sync就是做这个的

<li>
操作系统通常有一个后台进程（比如update），间隔地执行sync（比如30s）

</ol>
 
<p>
<strong>chdir＆chroot系统调用:</strong>
</p>
<ol>
<li>
chdir 改变当前目录

<li>
chroot 改变根目录

<ol>
<li>
只有root用户可以执行

<li>
执行后，绝对路径就会从这个新根目录开始

</ol>
</ol>
   
<h3 id="toc_1.4.5">保护系统调用System Calls for Protection</h3>

<ol>
<li>
每个文件都一个 <strong>11</strong> 位的保护方式码

<li>
其中9位表示owner,group, others对文件的读、写、执行权限

<li>
系统调用 <strong>chmod</strong> 可以改变一个文件保护模式

<li>
另 <strong>2位</strong> 是 <code>02000</code> 和 <code>04000</code> 分别代表 SETGID位和SETUID位

<li>
real UID, real GID, effective UID, effective GID

<ol>
<li>
默认都是指向 <strong>执行这个文件</strong> 的 user 和 group

<li>
若设置了SETUID(04000), effective UID就会指向文件的owner

<li>
若设置了SETGID(02000), effective GID就会指向文件的group

</ol>
</ol>
 
<p>
<strong>getuid＆getgid系统调用:</strong>
</p>
<ol>
<li>
getuid:同时返回real UID和effective UID

<li>
getgid:同时返回real GID和effective GID

<li>
有四个对应的库函数，用于返回特定的信息：getuid geteuid getgid getegid

</ol>
 
<p>
<strong>setuid＆setgid系统调用:</strong>
</p>
<ol>
<li>
一般用户是不能改变uid的，除非执行了一个设置了SETUID的文件，这里就会把effective UID设置为这个文件的owner,而不是执行这个文件的用户，当然它们也可以相同

<li>
root用户可以随意修改

<ol>
<li>
setuid：同时修改real UID和effective UID

<li>
setgid：同时修改real GID和effective GID

</ol>
</ol>
   
<p>
<strong>umask系统调用:</strong>
</p>
<ol>
<li>
<code>umask(022)</code>

<li>
设置一个内部掩码，创建文件时使用(creat mknode), 用于 <strong>关掉某些模式位</strong> 

<li>
<code>creat("file", 0777)</code>:0777与022的反码相与得0755，这才是真正的权限

<li>
一般用户就可以执行，且会被子进程继承

</ol>
 
<p>
<strong>access系统调用:</strong>
</p>
<ol>
<li>
检查对一个文件是否具有某种访问权限

</ol>
 
<h3 id="toc_1.4.6">时间系统调用System Calls for Time Management</h3>

<p>
<strong>time系统调用:</strong>
</p>
<ol>
<li>
返回距1970/01/01 00:00(这天的开始）的秒数

</ol>

<p>
<strong>stime系统调用:</strong>
</p>
<ol>
<li>
设置系统时间

</ol>

<p>
<strong>utime系统调用:</strong>
</p>
<ol>
<li>
允许文件owner或root设置文件在i-node表中的时间

</ol>

<p>
<strong>times系统调用:</strong>
</p>
<ol>
<li>
返回进程的统计信息，比如用了多少cpu时间，操作系统用了多少cpu时间 。。。。

</ol>

			</div>

			<div id="bottom">
				&copy; 2012 王兴朝
			</div>
		</div>
	<div>
</body>
</html>
