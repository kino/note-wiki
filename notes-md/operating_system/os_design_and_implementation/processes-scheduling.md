%title Scheduling 

## Introduction to Scheduling
当两个或多个process同时处于ready状态时，cpu需要决定运行哪个process(单cpu).
这种选择称之为进程调度Scheduler.
所使用的算法，称之为调度算法Scheduler Algorithm.

### Process Behavior
* 几乎所有的Process都会在I/O请求与计算之间轮换
* __compute-bound__: 计算密集形process, 大部分时间用于计算
* __i/o-bound__: i/o密集形process, 大部分时间用于I/O等待
  * 之所以称之为I/O密集形，是因为I/O请求之间，计算也不多
* 进程的趋势越来越顷向于I/O限制，这是因为cpu的发展速度远远快于disk的发展

### When to Schedule

#### 何时会产生调度:
* 当一个进程退出时
* 当一个进程阻塞于I/O或信号量时
* 当一个进程被创建时
* 当产生一个I/O中断时
* 当产生一个时钟中断时

#### 调度类型：
* __non-preemptive__ : 非抢占式调度， 一个运行的进程会一直运行到自身阻塞或退出或自愿让出cpu
* __preemptive__ : 抢占式调度，每过一定的时间，进行重新调度，依赖于时钟中断

### Categories of Scheduling Algorithms

不同的系统和环境对于调度算法的需求是不一样的，系统一般可分为三类：

* Batch 批处理系统
* Interactive 交互式系统
* Real Time 实时系统

对于批处理系统，非抢占式调度， 或着具有较长周期的抢占式调度都可以，这样可以有效的减少进程切换，提高性能。

对于交互式系统，抢占式调度是必要的，防止一个进程长期霸占CPU。

对于实时系统，抢占式足够了，有时甚至不需要。因为此系统中的进程运行都很快或很快被阻塞。和交互系统相比，不同的是
这里的进程基本上都是受控的。


### Scheduling Algorithms Goals

所有系统：

* 公平性 -- 给每个进程公平的cpu份额
* 特定策略 -- 特定策略能得到执行
* 平衡性 -- 使系统各组件保持忙碌

批处理系统:

* 吞吐量 -- 最大化每小时完成的工作数
* 平均完成时间 -- 最小化job从提交到完成的平均时间（turnaround time)
* Cpu利用率 -- 一直使Cpu处于忙碌状态

交互系统:

* 响应时间 --  尽量快的响应
* 期望值比例 -- 保证大部分的响应付合用户期望

实时系统:

* Meeting deadlines -- 不要错失要处理的数据
* 可预测性 -- 能保证稳定的处理数据，不稳定，比如声音与图像，就会大大降低意度

## Scheduling in Batch Systems

### First-Come First-Served
* 非抢占式算法
* 先到先服务
* 简单，公平
* 不能有效的利用资源，特别是当cpu密集性任务与io密集性任务混合时

### Shortest Job First
* 非抢占式算法
* 最短任务优先
* 可以缩短任务的平均执行时间，turnarround time
* 仅在所有任务同时开始的状况下，有优势

### Shortest Remaining Time Next
* 抢占式算法
* 最短任务算法的抢占式版本
* 最短剩余时间任务优先
* 当一个新任务到达时，会先比较新任务所需的时间与当前进程执行所剩余的时间，如果新任务所需更短的时间，则会挂起当前进程，执行新任务。


### Three-Level Scheduling
三级调度算法：

1. 入口调度器 Admission Scheduler
   * 入口处有一job等待队列
   * 调度器决定哪些job可以进入批处理系统
   * 调度算法通常是计算型与io型job混合进入系统，所需时间短的job优先进入系统
   * 进入系统的job,会为其创建一个进程
2. 内存调度器 Memory Scheduler
   * 当进入系统的job的太多时，对应的进程也会很多，内存可能不够
   * 有些进程可能需要被交换到磁盘上
   * 内存调度器决定哪些进程在内存里，哪些在磁盘上
   * 在内存里的进程才能真正被分配到cpu,从而被执行
   * 内存调度器，需要不定期的检查，看哪些需要交换到磁盘，哪些需要被交换回内存,做选择的依据大体包括：
     1. 进程被换入或换出多长时间了
     2. 进程最近使用了多少cpu
     3. 进程占用空间多大
     4. 进程的重要程度
3. Cpu调度器  Cpu Scheduler
   * 也就是我们常讲的调度算法
   * 可以使用任何一种调度算法，包括前面所提到的

## Scheduling in Interactive Systems
交互系统通常采用两级调度: Memory Scheduler and Cpu Scheduler

### Round-Robin Scheduling
* 时间片轮转调度，每个进程每次执行一个固定的时间，这个固定的时间就是时间片 **Quantum**
* 所有就绪的进程放入一个队列中
* 从队列中取出一个进程，运行一个时间片，将其放入队列尾部，从队列中取出下一个进程运行
* 切换运行进程时，称之为 **Process Switch** or **Context Switch**
* 当一个进程使用完自己的时间片，或着没有使用完，但被阻塞或自身结束时，就会产生 **Context Switch**
* **Context Switch** 是有成本的，更新寄存器，缓存等
* 时间片长度的选择
    * 设置太短，导致过多的 **Context Switch**， 降低cpu效率
    * 设置太长，可能会使本应该可以快速响应的请求变差


### Priority Scheduling
* 时间片轮转调度假定了进程间的重要程度是等同的。
* 现实中，进程的重要程度是不同的，某些时候需要优先运行某些进程
* 产生了优先级调度算法
  * 给每个进程分配一个优先级
  * 每次运行就绪进程中优先级最高的那个
* 如何防止最高优先级进程无限运行
  * 方法一，每次时钟中断时，给当前运行进程进行降级操作，再次查看哪个是优先级最大的进程并运行之
  * 方法二，给进程分配一个最大的时间片，消耗完后，运行那个比其优先级次之的那个进程
* 优先级可以静态赋值，也可以动态调整
  * 进程启动时，就可以分配一个优先级，比如系统进程高于用户进程
  * 动态调整，比如对于io型进程，给其分配一个优先级1/f,  f是该进程最后一次消耗时间片的分数
* 可以将进程进行分组，组之间通过优先级调度算法，组内进程使用时间片轮转调度算法
  * 当一个高优先级组内有进程时，对其内部使用时间片轮转调度，永远不会受低优先级组影响
  * 直到一个高优先级组为空时，次优先级组再会被调度到，对其内部采用时间片轮转调度

### Multiple Queues
如何对优先级进行分组，或着说如何决定一个进程在哪个组里？

比如，如果进程切换开销比较大，如何减小进程切换开销，一个有效的方法就是每个进程每次运行更多的时间片，减少切换。
但同时如何保证交互式进程的响应速度，可以使用如下策略：

* 最高优先级组里的进程每次运行一个时间片，次优先级组里的进程每次运行两个时间片，次次优先级组里的运行4个时间片，依次类推。。。
* 即一个优先级组里的进程运行的时间片是比这个组高一级的两倍，但至少是一个时间片
* 当一个进程开始时会放入最高优先级组里，每次被切换出时，降一个组
* 即随着进程进行时间的增长，优先级越来越低
* 如何保证交互式进程的响应时间：如果在等待一进程的终端里敲一下回车，该进程会被提升到最高优先级组，响应加快(但这会成为一种秘技，知道的人越多，作用越小)

另一种分组方式：

* 分为四组，优先级从高低依次为：terminal, i/o, short-quantum, long-quantum
* 一个进程等待终端输入，被唤醒时，放入terminal组
* 一个进程等待i/o, ready时，被放入i/o组
* 一个进程默认会在short-quantum组
* 一个进程连续多次使用完分配的时间片，会进入long-quantum组

### Shortest Process Next
最短进程优先，可以最小化平均响应时间，在批处理系统中如是，在交互式系统中同样如此。
在交互式系统中，如何找出下一个要运行的最短进程。

可以通过以往每次调度后的运行时间进行评估：

* 估计一个进程运行时间T0
* 测量到运行时间为T1, 可以升级我们的估计值(T0是估计值，T1会实测值， 结果变为新的T0)： aT0 + (1 - a)T1
* 0 < a < 1, 可以调节a的值，达到一个想要的效果，比如a=1/2
* 历史越久，响应越小

这样利用估计值和前一次的实测值，得出下一次估计值的技术称之为 **aging**

### Guaranteed Scheduling
保证调度算法，向用户或进程作出承诺，他们应得的cpu资源。
一种简单保证：

* n个用户登录，每个用户获得1/n cpu
* 单用户，n个进程，每个进程获得1/n cpu
* 需要追踪一个进程创建亦始，真正使用的cpu的时间
* 一个进程应得的cpu时间: (创建开始~now)/n
* 比率： 使用的/应得的
* 调度算法运行比率最小的进程，直到不是最小

### Lottery Scheduling
可预测调度结果的一种算法： 彩票调度算法

* 给进程发放针对各种系统资源的彩票，比如cpu 彩票
* 每次调度时，随机抽取一张彩票，持有这张彩票的进程将获得对应的资源
* 比如cpu调度，若每秒钟调度50次，每次持有彩票的进程将获得20msCPU资源
* 可以给更重要的进程发放更多的彩票，增加它们的中奖机率，从而获得更多的系统资源
* 该算法反应迅速，一个新建进程被发放一定的彩票，接下来就有对应的机率被运行
* 相关进程可以合作
    * client进程发关信息后被阻塞，可以将自己的彩票借给server进程
    * server进程得到彩票后，可增加中奖机率，即运行机率
    * 运行后，将彩票还给client进程，使client进程继续运行
    * 在没有client的情况下，server根本不需要彩票

### Fair-Share Scheduling
* 前面讨论的进程调度都是基于进程本身，并没有考虑该进程属于哪个用户
* 很可能造成用户间的不公平
* 可以先基于用户分配CPU，用户内的进程再按算法调度

## Scheduling in Real-Time Systems

## Policy versus Mechanism

## Thread Scheduling
