%title 指针与数组
=指针与数组=

日期: 2012-05-16 21:05
%toc

==指针与地址==

===指针===
# 指针是一类变量.
# 这类变量用于存储变量的地址.

===取址运算符&===
{{{ class="brush:c"
  &c;
  //用于取得变量c的内存地址.
  }}}
# 只能用于内存中的对象.
# 不能用于表达式,常量,寄存器变量.
# 它返回一个指针类型的变量.
  # 其实它返回一个地址类型的值,这个值只能赋值给接受地址为值的对象
  # 比如指针,数组名
  # 指针是有类型,比如存储整型变量的指针,存储char型变量的指针.
  # 如果将char型变量的地址赋给用于存储整型变量的指针,编译器会警告信息.
 
===间接寻址/引用运算符*===
{{{ class="brush:c"
  *ip;
  //用于访问ip这个地址指向的对象.
  //ip可能是指针，也可能是数组名
  //也就是说不一定只有指针存储地址。
  }}}
# 当它作用于指针时,用于访问指针所指向的对象.
 
===指针的声明===
{{{ class="brush:c"
  int *ip;
  }}}
# 上面的语句表明表达式`*ip`的结果是int型,但`ip`才是变量名，才是一个指针。
# 和函数的声明类似.
# _*指针只能指向特定类型的对象*_ ，也就是指向某种特定的数据类型。
  # _*一个例外是指向void类型的指针可以存放指向任何类型的指针. 但不能间接引用其自身*_
  
===指针也可以运算===
# 指针`pa`指向一个特定的元素
# 指针`pa+1`指向下一个元素
# 指针`pa+i`指向`pa`指向元素后的第i个元素
# 指针`pa-i`指向`pa`指向元素前的第i个元素
# _*指针指向的地址是可以加减运算的，只是运算的单位是指针所指向数据类型的地址单位，比如char是一个字节，short是两个字节等*_

  
==指针与函数参数==
# 函数的参数是值传递
# 可以传递指针参数实现类似java中的引用传递。
 
==指针与数组==

===数组===
{{{ class="brush:c"
  int a[10];
  //声明一个长度为10的int型数组。
  }}}
# _*数组名a是一个指向数组a第一个元素的地址。*_
	{{{ class="brush:c"
	   a==&a[0];//为true
	   //所以
	   int *pa;
	   pa=&a[0];
	   //等价于
	   pa=a;
	  }}}
# _*元素a[i]的多种方法*_
	{{{ class="brush:c"
	   int *pa;
	   pa=a;
	   //a[i]的表示方法：
	   a[i];
	   *(pa+i);
	   *(a+i);
	  }}}
  * _*在c中a[i]就是转换为*_ `*(a+i)` _*访问的*_
# _*数组名a不是变量，所以它和指针是不同的，也不能对它进行赋值, 它只是代表一个地址*_
# _*数组名传给函数时，实际上传进去的是第一个元素的地址*_
  * 所以形式参数可以是指针，也可以是这种形式：`a[]`
# _*数组结下标实际是没有限制的，可以是负值a[-2],也可大于长度a[12]*_
  # int a[10]只是说明初始化时，分配了连续的10个int型内存。
  # _*负值下标或大于长度的下标，只要内存是有效的就可以了，无效时会报内存错误.*_
   
===指针借鉴数组的访问方法===
# 如果`pa`是个指针
# `pa[i]`与`*(pa+i)`是等价的。
 
==地址算术运算==
 
===特殊的指针值０===
# 指针和整数之前不能相互转换
# 但`0`是唯一的例外
# 常量０可以赋值给指针，指针也可以和常量０进行比较
# Ｃ中常用符号常量NULL表求０

===指针可以和整数进行相加或相减的运算===
	{{{ class="brush:c"
	   p+n;
	  }}}
# p为指针，p+n指向p当前所指对象之后第n个对象的地址。
# 计算p+n时，n会根据p指向的对象长度按比例缩放：
  # p指向对象的长度取决于p的声明
  # 如果是int，占４个字节的存储空间
  # n按４的倍数计算
# p与q为指向数组中的指针，　p<q, 则q-p+1为p与q间的元素个数
 
===有效与非法的指针运算===

====有效指针运算====
* 同类型指针间的赋值运算
* 指针同整数间的加减运算
* 指向 _*同一数组元素*_ 间的 _*减法*_ 运算 
* 将指针赋值为0的运算
* 指针与0比较的运算
 
====其他的指针运算都是非法的====
* 两个指针间的加法减法乘法除法移位或屏蔽运算
* 指针同float double的加法运算
* 不经强制转换,一种类型指针赋值给另一种类型的指针　void *类型除外

==字符指针与函数==
# 传给函数的字符串，实际上传的是每一个字符的指针，所以函数形参可以是字符指针也可以是字符数组
# 字符指针可以直接通过字符串赋值
  {{{ class="brush:c"
    char *p;
    p = "hello world!";
	}}}
# C语言没有提供将整个字符串作为一个整体的运算符
# 字符数组定义与字符指针定义的区别
  {{{ class="brush:c"
    char amessage[] = "nw is the time"; /* 定义一个数组 */
    char *pmessage = "now is the time"; /* 定义一个指针 */
    
    //amessage是一个数组，数组中的单个字符可以修改
    //但amessage始终指向同一个存储位置

    //pmessage是一个指针，指向一个字符串常量
    //但它可以修改指向另一个地址
	}}}
	
==指针数组及指向指针的的指针==

* 指针本身也是变量，所以它们也可以存储在数组中
* 注意这里的数组变量 lineptr 可以改变值
  {{{ class="brush:c"
		/* writelines: write output lines */
		void writelines(char *lineptr[], int nlines)
		{
			while (nlines-- > 0)
				printf("%s\n", *lineptr++);
		}
	}}}
	
==多维数组==

# 二维数组是一种特殊的一维数组，它的每个元素是一个一维数组
# 二维数组的行数没太大关系，但要指明列数
# 二级数组作业函数参数时，形参可以声明为：
  {{{ class="brush:c"
    f(int daytab[2][13]){...}
    f(int daytab[][13]){...}
    f(int (*daytab)[13]){...}
    //声明参数是一个指针，指向具有13个元素的一维数组
    //[]优先级高于*
	}}}
	
==指针数组的初始化==

==指针与多维数组==
  {{{ class="brush:c"
  int a[10][20];
  int *b[10]
	}}}
*上面两者的区别*
* `a[3][4]`与`b[3][4]`语法上是合法的
* 对于a:
  # a是一二维数组，它分配了一个200个int型的存储空间
  # 通过常规矩阵计算下标：`row*20+col`
* 对于b:
  # b是一个指针数组，未初始化
  # 必须显示初始化：静态初始化或代码初始化
  # 如果b的每个元素都指向一个具有20元素的数组
  # 会分配200个int型的存储空间和10个指针的存储空间
* b的优点： *每个元素可以指向不同长度的数组*
* 存储空间比较
  # 指针数组
    {{{ class="brush:c"
      char *name[]={"Illegal manth", "Jan", "Feb", "Mar"};
      }}}
    [p59.png]
  # 二维数组
    {{{ class="brush:c"
      char aname[][15] = { "Illegal month", "Jan", "Feb", "Mar" };
      }}}
    [p10.png]


==命令行参数==

* 可通过命令行将参数传递给程序
* 调用主函数main时带有两个参数
  * `argc`:表示参数个数
  * `argv`: 是一个指向字符串指针数组的指针，每个字符串对应一个参数
    {{{ class="brush:c"
      char *argv[]
	  }}}
* C语言约定，`argv[0]`的值是启动该程序的程序名，因此`argc`至少为1
* 解析以`-`开头的可选参数
    {{{ class="brush:c"
       while(--argc>0 && (*++argv)[0]=='-')
		   while(c=*++argv[0])
			   switch(c){
                 case: 'x'
                 ...
			   }
	   //(*++argv)[0]可用**++argv代替;  []优先级高
	  }}}

==指向函数的指针==

* 函数本身不是变量，但可以定义指向函数的指针
* 这种类型的指针可以被赋值、存放在数组中，传递给函数及作为函数返回值等等
  # 函数声明，接受一个函数指针参数
    {{{ class="brush:c"
        void qsort(void *lineptr[], int left, int right,
                   int (*comp)(void *, void *));
        //comp是一个接受两个指针作为参数，并返回一个整型的函数指针
        //参数声明为void *型，这样qsort就可以处理任何类型的排序了
	  }}}
  # 传递函数名作为参数
    {{{ class="brush:c"
        qsort((void**) lineptr, 0, nlines-1,
                  (int (*)(void*,void*))(numeric ? numcmp : strcmp));
        //numcmp、strcamp本身代表了函数的地址，所以前面不需要取址符，同样的原因，数组名也不需要
	  }}}
  # 使用作为参数的函数指针
    {{{ class="brush:c"
        if ((*comp)(v[i], v[left]) < 0)
            swap(v, ++last, i);
        //comp是一个指向函数的指针，*comp代表一个函数
	  }}}
* _*任何指针类型都可以转换为*_ `void *` _*类型的指针，并把它转换回原先的类型时，不丢失信息*_
	  
==复杂声明==




