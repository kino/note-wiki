%title 一元和二元操作符
=一元和二元操作符=
日期: 2012-06-08 11:06
%toc

==箭头操作符==
* 如果右边是一个[...]数组脚标，一个{...}散列脚标，一个(...)子例程参数列表
  * 左边必须是一个对应的数组、散列、或子例程引用
    {{{ class="brush:perl"
        $aref->[42]              #一个数组析值
        $href->{"corned beff"}   #一个散列析值
        $sref->(1,2,3)           #一个子例程析值
	  }}}
* 否则它就是某种方法的调用
  * 右边必须是一个方法名，或包含方法名的简单标量变量
  * 左边必须是一个对象名，或一个类的名字
    {{{ class="brush:perl"
        $yogi = Bear->new("Yogi");     #一个类方法调用
	    $yogi->swipe($picnic);         #一个对象方法调用
	  }}}

==自增和自减操作符==
* 如果在数字环境中，就是我们所认识的正常功能。
* 如果在字符串环境中，且匹配模式 /^[a-zA-Z]**[0-9]**$/
  * 采用字符串方式，且会进位
    {{{ class="brush:perl"
        print ++($foo = '99'); # 打印'100'
        print ++($foo = 'a0'); # 打印'a1'
        prin ++($foo = 'Az'); # 打印'Ba'
        print ++($foo = 'zz'); # 打印'aaa'
	  }}}
	  
==指数运算==
-2***4, 是-(2****4), 而不是(-2)***4

==表意一元操作符==
* `!`逻辑否
* `-`
  * 如果是数字，数学取负
  * 如果是一个标识符，返回一个由负号和标识符连在一起的字符串
* `~`
  * 如果是数字，按位取反
  * 如果是字符串，返回等长字符串，但所有字符串所有的位都是互补的
* `+`
* `\`
  * 给它后面的东西创建一个引用
   
==邦定操作符==
* `=~`
  * 将一个字符串和一个模式进行匹配、替换、或者换字绑定在一起。
  * 字符串放左边，操作符放右边
  * 返回值说明操作符是否成功
  * 绑定操作符本身实际上不做任何事情
  * 如果右边只是一个表达式，将进入搜索模式
    {{{ class="brush:perl"
		  $_=~$pat;
          #等效于：
		  $_=~/$pat/;
	  }}}
* `!~`
  * 与`=~`类似，返回值是`=~`对应返回值的逻辑非
    {{{ class="brush:perl"
          $string !~ /pattern/;
          #等效于：
          not $string =~ /pattern/;
	  }}}
   
==乘号操作符==
* `* / %`
* `x` 复制操作符
  * 标量环境，返回一个由左操作数重复右操作数次数连接起来的字符串
  * 列表环境，如果左操作数是在小括号中的列表，`x`的作用是一个列表复制器
    {{{ class="brush:perl"
        @ones = (1) x80;     #一个 80 个 1 的列表
        @ones = (5) x @ones; #把所有元素设置为 5
        
        #类似,你还可以用 x 初始化数组和散列片段:
        @keys = qw(perls before swine);
        @hash{@keys} = (" ") x @keys;
        #在赋值语句右边@keys当做一个标量值(返回数组长度)。
	  }}}


==附加操作符==
* `+ -` 把参数从字符串转换为一个数字值
* `.`连接字符串

==移位操作符==
* `>> <<`
 
==命名一元操作符==

* 表 3-2 命名单目操作符
| -X (file tests) | gethostbyname  | localtime | return  |
| alarm           | getnetbyname   | lock      | rmdir   |
| caller          | getpgrp        | log       | scalar  |
| chdir           | getprotobyname | lstat     | sin     |
| chroot          | glob           | my        | sleep   |
| cos             | gmtime         | oct       | sqrt    |
| defined         | goto           | ord       | srand   |
| delete          | hex            | quotemeta | stat    |
| do              | int            | rand      | uc      |
| eval            | lc             | readlink  | ucfirst |
| exists          | lcfirst        | ref       | umask   |
| exit            | length         | require   | undef   |

* 一元操作符比起某些二元操作符优先级高
  {{{ class="brush:perl"
      sleep 4 | 3;
      # 等价于
      (sleep 4) | 3;
	}}}
* `print`是一个列表操作符，而不是一元操作符
  {{{ class="brush:perl"
      print 4 | 3;
      # 等价于
      print (4 | 3);
	}}}
* 可以用小括号把一个命名的一元操作符转换成一个函数
* 一元操作符没有参数时，默认使用`$_`
* 下列记号被称为模糊字符，它会根据需要将自身转换为操作符或项。一元操作符后期待一个项
表 3-3 模糊字符
| 字符 | 操作符      | 项                  |
|------|-------------|---------------------|
| +    | 加法        | 单目正号            |
| -    | 减法        | 单目负号            |
| *    | 乘法        | *类型团             |
| /    | 除法        | /pattern/           |
| <    | 小于号,左移 | <HANDLE>,<<END      |
| .    | 连接        | .3333               |
| ?    | ?:          | ?pattern?           |
| %    | 模除        | %assoc              |
| &    | &, &&       | &subroutine(子过程) |

* 一个典型的错误
  {{{ class="brush:perl"
      #这里<会被当成输入符号<>的开始，而不是一个小于号，因为一元操作符length后期待一个项
      next if length < 80;
      
      #如果实在不想打$_,可以使用下列方式
      next if (length) < 80;
      next if length() < 80;
      next if  80 > length;
      next unless  length >= 80;
	}}}
 
==文件操作测试符==
* 当解析器需要一个项时，负号加一个字母会被当成一个文件测试符
* 它是接受一个参数的一元操作符
* 省略参数时，将`$_`当成参数，`-t`除外，它将测试`STDIN`
表 3-4 文件测试操作符
| 操作符 | 含义                                            |
|--------|-------------------------------------------------|
| -r     | 文件可以被有效的 UID/GID 读取。                 |
| -w     | 文件可以被有效的 UID/GID 写入。                 |
| -x     | 文件可以被有效的 UID/GID 执行。                 |
| -o     | 文件被有效 UID 所有                             |
| -R     | 文件可以被真实的 UID/GID 读取。                 |
| -W     | 文件可以被真实的 UID/GID 写入。                 |
| -X     | 文件可以被真实的 UID/GID 执行。                 |
| -O     | 文件被真实的 UID 所有                           |
| -e     | 文件存在                                        |
| -z     | 文件大小为零                                    |
| -s     | 文件大小不为零(返回大小)                        |
| -f     | 文件是简单文件                                  |
| -d     | 文件是目录                                      |
| -l     | 文件是符号连接                                  |
| -p     | 文件是命名管道(FIFO)。                          |
| -S     | 文件是套接字                                    |
| -b     | 文件是特殊块文件                                |
| -c     | 文件是特殊字符文件                              |
| -t     | 文件句柄为一个 tty 打开了                       |
| -u     | 文件设置了 setuid 位                            |
| -g     | 文件设置了 setgid 位                            |
| -k     | 文件设置了 sticky 位                            |
| -T     | 文件是文本文件                                  |
| -B     | 文件是一个二进制文件(与-T 对应)                 |
| -M     | 自从修改以来的文件以天记的年龄(从开始起)        |
| -A     | 自从上次访问以来的文件以天记的年龄(从开始起)    |
| -C     | 自从 inode 修改以来的文件以天记的年龄(从开始起) |

* 下划线`_`作为文件测试操作符的参数，将使用前一个文件测试使用的结构，省缺一个系统调用
  {{{ class="brush:perl"
      print "Can do. \n" if -r $a || -w _ || -x _;
	}}}
	   
	   
==关系操作符==

3-5 关系操作符
| 数字 | 字串 | 含义       |
|------|------|------------|
| >    | gt   | 大于       |
| >=   | ge   | 大于或等于 |
| <    | lt   | 小于       |
| <=   | le   | 小于或等于 |


==相等操作符==

表 3-6 相等操作符
| 数字 | 字串 | 含义            |
|------|------|-----------------|
| ==   | eq   | 等于            |
| =    | ne   | 不等于          |
| <=>  | cmp  | 比较,带符号结果 |


==位操作符==
* 如果两个操作数是数字，则将两个操作数转换为整数，再进行操作
  * 保证至少32位
* 如果两个操作数是字符串，将用两个字符串里面的位进行操作
  * 没有字长限制
  * 短的那个尾部用0补足
* 如果两个操作数一个是数字一个是字符串，则将字符串转换为数字，再进行操作

==短路操作符==
* `&& || and or`
* 不返回0或1，返回最后计算的值
* `and or`优先级低

==范围操作符==
* `..`
* 标量环境返回一个布尔值
  # 如果左操作数为假则一直为假
  # 如果左操作数为真，保持状态真直到右操作数为真。即右操作数为真，范围操作符为假
* 列表环境返回从左值到右值计数的数值
  {{{ class="brush:perl"
      if(101 .. 200) {print;}             #打印第二个一百行
      next line if( 1.. /^$/);            #忽略开头行
      s/^/> / if (/^$/ .. eof());         #引起体
      
      for (101 .. 200) {print;}           #打印 101102 。。。 199200
      @foo = @foo[0 .. $#foo];            #一个昂贵的空操作
      @foo = @foo[ -5 .. -1];             #最后 5 个元素的片段
      
      #如果左边的值大于右边的值,则返回一个空列表。
      
      @alphabet = ('A' .. 'Z');                      #以获得所有英文字母
      $hexdigit = (0 .. 9, 'a' .. 'f')[$num & 15];   #获得一个十六进制位
      @z2 = ('01' .. '31'); print $z2[$mday];        #获得带有前导零的日期
      @combos = ('aa' .. 'zz');                      #获取所有两个小写字符的组合。
      @bigcombos = ('aaaaaa' .. 'zzzzzz');           #要小心:
	}}}
	
==条件操作符==
`?:`

==赋值作符==
  {{{ class="brush:perl"
= **= += *= &= <<= &&=
      -= /= |= >>= ||=
      .= %= ^= 
         x=
	}}}
	

==逗号操作符==
* `,`
* 标量环境
  # 计算左参数，丢弃
  # 计算左参数，返回
  {{{ class="brush:perl"
      $a = (1,3); #$a为3
	}}}
* 列表环境
  # 只是列表参数的分隔符
  # 不会丢弃任何数值
  {{{ class="brush:perl"
      @a = (1,3); #构造了一个有两个元素的列表
	}}}
* `=>`大多数情况下是逗号的同义词
  # 强制将左边的标识符解释为一个字符串
	

==列表操作符(右向)==

==逻辑与、或、非和异或==

==没有的C操作符==
* `&`取址操作符，perl里有`\`
* `*`析值取址操作符，perl里不需要，因有有引用


	

